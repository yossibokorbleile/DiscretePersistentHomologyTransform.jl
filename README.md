# PersistentHomologyTransfer.jl

Persistent Homology Transform is produced and maintained by \
Yossi Bokor and Katharine Turner \
<yossi.bokor@anu.edu.au> and <katharine.turner@anu.edu.au> 

This package provides an implementation of the Persistent Homology Transform, as defined in [Persistent Homology Transform for Modeling Shapes and Surfaces](https://arxiv.org/abs/1310.1030). It also does Rank Functions of Persistence Diagrams, and implements [Principal Component Analysis of Rank functions](https://www.sciencedirect.com/science/article/pii/S0167278916000476).


## Installation
Currently, the best way to install PersistentHomologyTransfer is to run the following in `Julia`:
```julia
using Pkg
Pkg.add("PersistentHomologyTransfer")
```
## Functionality
- PersistentHomologyTransfer computes the Persistent Homology Transform of simple, closed curves in $\mathbb{R}^2$.
- Rank functions of persistence diagrams. 
- Principal Component Analysis of Rank Functions.

### Persistent Homology Transform
Given an $m \times 2$ matrix of ordered points sampled from a simple, closed curve $C \subset \mathbb{R}^2$ (in either a clockwise or anti-clockwise direction), calculate the Persistent Homology Transform for a set of directions. You can either specify the directions explicity as a $n \times 2$ array (`directions::Array{Float64}(n,2)`), or specify an integer (`directions::Int64`) and then the directions used will be generated by
```julia
angles = [n*pi/(directions/2) for n in 1:directions]
directions = [[cos(x), sin(x)] for x in angles]
```
To perform the Persistent Homology Transfer for the directions, run
```julia
PHT(points, directions)
```

This outputs an array of [Eirene](https://github.com/Eetion/Eirene.jl) Persistence Diagrams, one for each direction. 

### Rank Functions
Given an [Eirene](https://github.com/Eetion/Eirene.jl) Persistence Diagram $D$, PersistentHomologyTransfer can calculate the Rank Function $r_D$ either exactly, or given a grid of points, calculate a discretised version. Recall that $D$ is an $n \times 2$ array of points, and hence the function `Total_Rank_Exact` accepts an $n \times 2$ array of points, and returns a list of points critical points of the Rank function and the value at each of these points. Running 

```julia
rk = Total_Rank_Exact(barcode)
```
we obtain the critical points via
```julia
rk[1]
```
which returns an array of points in $\mathbb{R}^2$, and the values through
```julia
rk[2]
```
wich returns an array of integers.

To obtain a discrete approximation of a Rank Function over a persistence diagram $D$, use `Total_Rank_Grid`, which acceps as input an [Eirene](https://github.com/Eetion/Eirene.jl) Persistence Diagram $D$, an increasing `StepRange` for $x$-coordinates `x_g`, and a decreasing `StepRange` for $y$-coordinates `y_g`. The `StepRanges` are obtained by running

```julia
x_g = lb:delta:ub
x_g = ub:-delta:lb
```
with `lb` being the lower bound so that $(lb, lb)$ is the lower left corner of the grid, and `ub` being the upper bound so that $(ub,ub)$ is the top right corner of the grid, and $delta$ is the step size. 

Finally, the rank is obtained by

```julia
rk = Total_Rank_Grid(D, x_g, y_g)
```
which returns an array or values. 

### PCA of Rank Functions

Given a set of rank functions, we can perform principal component analysis on them. The easiest way to do this is to use the wrapper function `PCA` which has inputs an array of rank functions evaluated at the same points (best to use `Total_Rank_Grid` to obtain them), an dimension $d$ and an array of weights `weights`, where the weights correspond to the grid points used in `Total_Rank_Grid`.

To perform Principal Component Analysis and obtain the scores run

```julia
scores = PCA(ranks, d, weights)
```
which returns the scores in $d$-dimensions.

## Examples
### Persistent Homology Transfer
We will go through an example using a random [shape](https://github.com/yossibokor/PersistentHomologyTransfer.jl/Example/Example1.png) and 20 directions. You can download the CSV file from [here](https://github.com/yossibokor/PersistentHomologyTransfer.jl/Example/Example1.csv)

To begin, load the CSV file into an array in Julia 

```julia
Boundary = CSV.read("<path/to/file>")
Persistence_Diagrams = PHT(Boundary, 20)
```

You can then access the persistence diagram corresponding to the $i^{th}$ direction as

```julia
Persistence_Diagrams[i]
```
<!---### Rank Functions -->
